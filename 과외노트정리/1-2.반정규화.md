
# CH2.데이터 모델과 SQL

### 1. 정규화(Normalization)

* **데이터 정합성** : 데이터의 `정확성과 일관성 유지 및 보장`
* 정규화를 하는 이유 -> 데이터 정합성 보장 위해 엔터티를 쪼개는 과정

$\color{red}{\textrm{   주의:정규화가 무조건 조회성능을 향상 시키는 것은 아님.}}$  너무 많이 쪼개져있는 경우 여러번 JOIN 사용해야함<br>


### 정규화의 종류
  * 제 1 정규형
    * 하나의 속성 안에 여러 개의 속성값을 가졌을 때 $\color{red}{\textrm{사용자가 다중속성값을 사용할 때 split을 사용하는 번거로움}}$
    * 속성값이 들쭉날쭉하므로 공간낭비 발생
    * 속성값이 하나가 되도록 / 유사한 속성이 반복되지 않도록 엔터티를 분리

![image](https://user-images.githubusercontent.com/62399318/218247233-88dc6486-66f8-45d9-b7c4-49362f0f2f9c.png)
하나의 속성에 여러 가지의 값을 가지는 경우 제 1 정규형을 함
![image](https://user-images.githubusercontent.com/62399318/218247244-9ef76a80-f086-4d10-8c08-0eccb917c08a.png)
![image](https://user-images.githubusercontent.com/62399318/218247279-0fcef596-a3e7-4e95-aea3-9e200d9b05e3.png)
유사한 속성이 반복되는 경우도 1차 정규화의 대상이 된다.

  * 제 2 정규형
    * 주식별자가 복합식별자이고 다른 일반속성이 하나의 주식별자에만 종속될 때 
    * 그 주식별자와 해당 일반속성을 별도의 테이블로 분리한다.
   ![image](https://user-images.githubusercontent.com/62399318/218247812-c8c03a78-3320-4c34-b768-5c87bdffbc77.png)
   
  * 제 3 정규화
    * 모든 속성 간에는 서로 종속될 수 없다.(주식별자와의 종속은 제외)
    * 종속되는 속성들을 별도의 엔터티로 분리한다.
    ![image](https://user-images.githubusercontent.com/62399318/218247926-d68ff9c9-1c3b-4983-87ec-5333dda43f77.png)

### 반정규화(De-Nomalization)
* 개념
    * 데이터 조회성능을 향상시키기 위해 `데이터 중복 허용` or `데이터 그룹핑` 하는 과정
    * $\color{red}{\textrm{주의:조회성능은 향상되도 입력,수정,삭제 성능은 저하가능}}$
    * **반정규화는 무조건 정규화 끝난후에 거침**
* 테이블 반정규화   
  * 1. 테이블 병합
    * 업무 프로세스상 JOIN이 많이 필요한 경우가 많아 테이블을 통합하는 것이 성능 측면에서 유리할 때 2개의 엔터티를 합체하는 것

    $\color{red}{\textrm{일대다 관계 테이블 병합의 경우 '일'에 해당하는 테이블의 속성개수가 더 많으면 중복데이터가 많아지므로 테이블 병합에 적절치 못하다.}}$<br>

    __일대다 관계__ 란 일에 해당하는 엔터티가 여러개의 관계를 가질 수 있음
    * ![image](https://user-images.githubusercontent.com/62399318/218248356-05e45b74-6f96-4bcf-b239-0a1c36e3b421.png)

  * 2. 테이블 분할

    * 1) 테이블 분할
      * 엔터티의 일부 속성을 별도의 엔터티로 분할(**일대일 관계 성립**)
      * 자주 사용하는 속성이 아니거나 null이 가능한 속성값일 경우 고려
      * ![image](https://user-images.githubusercontent.com/62399318/218248858-1499424f-3e65-44d6-9930-ecc9aaecf6a5.png)
    * 2) 테이블 수평분할
      * 엔터티의 인스턴스를 특정 기준으로 별도의 엔터티로 분할(**파티셔닝 기능을 이용**)
      * ![image](https://user-images.githubusercontent.com/62399318/218249151-c2eb9018-7610-4185-9073-141daee08243.png)
    * 3) 테이블  추가
      * 중복 테이블 추가   
        * 데이터의 중복을 감안하더라도 성능상 반드시 필요하다고 판단되는 경우 별로의 엔터티를 추가
        * 용도 구분을 위해 같은 데이터를 다른 테이블에 저장하려는 경우(데이터 정합성은 물론 위배된다.)
      * 통계 테이블 추가
        * ![image](https://user-images.githubusercontent.com/62399318/218249221-eab56437-7b50-4cc4-ba4f-0b13f9f3ebbf.png)
      * 이력 테이블 추가
        * ![image](https://user-images.githubusercontent.com/62399318/218249250-0e4e8e33-b6ac-480d-8715-4eebd0be8e2c.png)
      * 부분 테이블 추가
        * ![image](https://user-images.githubusercontent.com/62399318/218249298-a418c27d-931f-4e26-b075-408ee6431c53.png)
* 컬럼 반정규화
  * 중복 컬럼 추가
    * 업무 프로세스상 JOIN이 필요한 경우가 많아 컬럼을 추가하는 것이 성능 측면에서 유리할 경우 고려
  * 파생 컬럼 추가
    * 프로세스 수행 시 부하가 염려되는 계산값을 미리 컬럼으로 추가하여 보관하는 방식
    * 상품 재고나 프로모션 적용 할인가
  * 이력 테이블 컬럼 추가
    * 대령의 이력 테이블을 조회할 때 속도가 느려질 것을 대비하여 조회 기준이 될 것으로 판단되는 컬럼을 미리 추가
    * 최신 데이터 여부 등이 이에 해당
          
    
 
  


